
## 无锁队列的实现



- ⚛️ 项目中用到的, 给 Actor 用作 mailbox 的一个无锁队列 ⚛️
- ⚛️ Multi Producer, Single Consumer, lockfree queue ⚛️



## 代码

```
import java.util.concurrent.atomic.AtomicReference;

/***/
public class MPSCQ<T>
{
	private MNode<T> anchor = new MNode<>(null);
	private AtomicReference<MNode<T>> pi = new AtomicReference<>(anchor);
	private AtomicReference<MNode<T>> ci = new AtomicReference<>(anchor);



	public void offer(T data)
	{
		MNode<T> node = new MNode<>(data);
		MNode<T> prev = pi.getAndSet(node);
		prev.setNext(node);
	}


	public T poll()
	{
		if(empty()) return null;
		MNode<T> lastConsumed = ci.get();
		while(true)
		{
			MNode<T> next = lastConsumed.getNext();
			if(next != null)
			{
				ci.set(next);
				return next.getData();
			}
		}
	}


	public boolean empty()
	{
		return pi.get() == ci.get();
	}
}

``` 

---
---
## 解释
- 思路解析
    - AtomicReference#getAndSet 
        - 这是个原子操作, 基于 CAS 
    - 这个 offer 方法是暴露在多个线程环境下的
    - 同步的步骤在 getAndSet 之后就已经完成了, 每个线程拿到的返回值只有该线程持有
    - 所以在 getAndSet 之后可以慢悠悠地 prev.setNext(node); 而没有线程安全问题 
    - 可以这样来形象化: 
        - 这个队列可以看作一个个用桥连起来的岛; 
        - 多个线程向 queue offer data 时, 由 getAndSet 原子操作, 会先把岛放在正确的位置, 而桥还没有搭起来. 
        - 搭桥的操作可以用普通操作, 这是因为到这一步时已经没有 race 了. 
        - 对于 Consumer, 能通过  empty() 判断这些岛是否已存在。 
        - 当岛存在时, 桥不一定搭好了, 或者说桥不一定对 Consumer 可见, busy wait 一下就可以了.  //这里可以优化为 lazySet, 




