## 无锁队列的实现


## 哪些地方需要用到重心坐标 barycentric coordinates
- ⚛️ 光栅化的过程中要判断某个pixel是否在三角形内 ⚛️
- ⚛️ 三角形内某个位置用 vertex attribute 插值 ⚛️



## 计算方式1
	对于某个点 P 相对于三角形 ABC 的重心坐标 ( u, v, w ) 有: 
		u + v + w = 1 

    P = (1-v-w)A + vB + wC 
    P = A + vAB + wAC 
    0 = vAB  + wAC + PA         // 左边是 0 向量
    由上式得到这样一个 linear system :
    vAB<x> + wAC<x> + PA<x> = 0		// AB<x> 为向量 AB 的 x 分量
    vAB<y> + wAC<y> + PA<y> = 0 
    观察得知 (v, w, 1) 与这两个向量同时垂直:  (ABx, ACx, PAx),   (ABy, ACy, PAy) 
    于是, (v, w, 1) 就能从  (ABx, ACx, PAx),   (ABy, ACy, PAy)  的 cross product 中求出来. 
    而最终的 barycentric coordinates 就是: 
    (u, v, w) = ( (1-v-w), v, w )

```
Vec3f barycentric(Vec2i *pts, Vec2i P) { 
    Vec3f u = cross(
		Vec3f(pts[1][0]-pts[0][0], pts[2][0]-pts[0][0], pts[0][0]-P[0]), 
        Vec3f(pts[1][1]-pts[0][1], pts[2][1]-pts[0][1], pts[0][1]-P[1])
		);
    if (abs(u[2])<1) return Vec3f(-1,1,1); /*  edge case */
    return Vec3f(1.0f-(u.x+u.y)/u.z, u.x/u.z, u.y/u.z); 
} 

```
## 计算方式2

- 这个办法要用到 克莱姆法则
- 主要分析下面这个代码是怎么来的:   
```
// Compute barycentric coordinates (u, v, w) for
// point p with respect to triangle (a, b, c)
void Barycentric(Point p, Point a, Point b, Point c, float &u, float &v, float &w)
{
    Vector v0 = b - a, v1 = c - a, v2 = p - a;
    float d00 = Dot(v0, v0);
    float d01 = Dot(v0, v1);
    float d11 = Dot(v1, v1);
    float d20 = Dot(v2, v0);
    float d21 = Dot(v2, v1);
    float denom = d00 * d11 - d01 * d01;
    v = (d11 * d20 - d01 * d21) / denom;
    w = (d00 * d21 - d01 * d20) / denom;
    u = 1.0f - v - w;
}
```



	对于某个点 P 相对于三角形 ABC 的重心坐标 ( u, v, w ) 有:
	v(B − A) + w(C − A) = P − A
	可以写成:
	v v0 + w v1 = v2      // 1式   // 其中 v0 = B − A, v1 = C − A,  v2 = P − A 
	由上式我们可以得到一个 linear system:
	1式左右点乘 v0 得到: 
		(v v0 + w v1) · v0 = v2·v0			
	1式左右点乘 v1 得到: 
		(v v0 + w v1) · v1 = v2·v1	
	变换后得到:
		v (v0·v0) + w (v1·v0) = v2·v0
		v (v0·v1) + w (v1·v1) = v2·v1
	于是上面这个 linear system 可以写成 Ax=b  的形式, A 为系数矩阵:
		[
			v0·v0     v1·v0
			v0·v1     v1·v1
		]
	令:
		d00 = v0·v0 ;
		d01 = v0·v1 ;
		d11 = v1·v1 ;
		d20 = v2·v0 ; 
		d21 = v2·v1 ; 
	则 A 可以写成:
		[
			d00    d10
			d10    d11
		]
	而 Ax=b 中, x = (v, w)T,  b=(d20, d21)T			// x, b 是 column vector, (v, w)T 中的 T 表示 transpose.  //没弄好 markdown math plugin
	由 克莱姆法则 可以直接得出 Ax=b 中的 x 各分量: 也即能直接求出 v, w 
	float denom = d00 * d11 - d01 * d01;
	v = (d11 * d20 - d01 * d21) / denom;
	w = (d00 * d21 - d01 * d20) / denom;
	u = 1.0f - v - w; 
- 完成







